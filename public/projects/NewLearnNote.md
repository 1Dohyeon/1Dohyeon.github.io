# NewLearnNote: AI와 집단지성 기반 지식 관리 및 노트 앱

이 문서는 프로젝트를 시작한 이유부터 배운 점까지 프로젝트 경험을 중심으로 작성되었습니다. **코드 구현 세부사항, 아키텍처 설계, 사용 방법 등** 기술 문서는 [GitHub README](https://github.com/newlearnnote/newlearnnote.github.io/blob/main/README.md)에서 확인하실 수 있습니다.

## 프로젝트 개요

![nln-main-img](https://github.com/1Dohyeon/1Dohyeon.github.io/blob/main/public/nln-main-img.png?raw=true)

> 서비스 정보
>
> - 서비스명: NewLearn Note
> - 비전: AI와 집단지성을 활용한 차세대 지식 관리 및 학습 플랫폼
> - 배포 상태: 테스트 서버 배포

### 왜 이 프로젝트를 시작했는가?

**옵시디언에서 공부하고, 블로그에 공유하고, 구글링으로 자료 찾으면서 공부할 때마다 여러 페이지를 왔다갔다하는 게 너무 귀찮았습니다.**

이 불편함을 해결하기 위해 NewLearn Note를 기획했습니다. 노트 작성, 공유, 다른 사용자의 학습 자료 참고를 하나의 앱에서 해결하는 것이 목표입니다. 향후 "이 파일 참고해서 필기해줘"와 같은 AI 어시스턴트 기능도 계획 중이며, 해당 프로토타입은 [Nura](https://1dohyeon.github.io/#/projects/nura)에서 개발했습니다.

### 핵심 기능: Library와 노트 네트워크

GitHub에서 Repository에 코드를 push/pull하듯, NewLearn Note에서는 **Library**에 노트를 동기화합니다.

- **Library 구조**: 각 Library는 `private`과 `public` 브랜치로 구성
- **동기화**: 로컬 폴더와 Library 간 push/pull로 노트 동기화 (private 브랜치에 저장)
- **Publish**: 로컬에서 Publish 버튼 클릭 시, 해당 노트와 백링크(`[[ ]]` 문법)로 연결된 노트들이 public 브랜치에 복제
- **노트 네트워크**: 다른 사용자가 공개된 노트를 자신의 노트에서 link로 참조하면, DB의 `note-network` 테이블에 관계가 저장되어 집단지성 네트워크 형성

## 주요 개발 경험과 기술적 의사결정

### 1. 크로스 플랫폼 환경의 인증 문제 해결

**직면한 문제:**
웹과 데스크톱 앱을 동시에 지원하면서, 각 플랫폼의 특성이 달라 인증 방식 설계에 고민이 있었습니다. 웹은 stateless한 환경이지만, 데스크톱 앱 사용자는 매번 로그인하는 것을 불편해할 것 같았습니다.

**해결 과정:**
1. **플랫폼별 인증 전략 분리**
   - 웹: JWT 기반 stateless 인증으로 서버 확장성 확보
   - 데스크톱: 세션 기반 자동 로그인으로 사용자 편의성 개선

2. **보안 강화**
   - Google OAuth 클라이언트 ID를 웹/데스크톱 별도로 분리
   - 이유: 데스크톱 앱의 클라이언트 시크릿 노출 위험 방지

3. **토큰 만료 처리**
   - JWT 토큰 자동 갱신 로직 구현
   - 사용자가 작업 중 갑자기 로그아웃되지 않도록 개선

**학습:**
같은 기능이라도 플랫폼 특성에 따라 다른 접근이 필요하다는 것을 배웠습니다. 특히 사용자 경험과 보안성을 동시에 고려한 시스템 설계의 중요성을 깨달았습니다.

### 2. RAG 파이프라인 기반 AI 어시스턴스 개발

**배경:**
NewLearn Note에 통합될 AI 문서 분석 기능을 독립 프로젝트([Nura](https://1dohyeon.github.io/#/projects/nura))로 먼저 개발하여 프로토타입을 검증했습니다.

**기술적 구현:**
- **FastAPI 기반 RAG 파이프라인 설계**
  - LangChain으로 문서 처리 및 임베딩
  - ChromaDB를 활용한 벡터 검색 구현
  - OpenAI API 통합 및 프롬프트 엔지니어링

- **문서 처리 최적화**
  - PDF/Markdown/Text 파일 파싱
  - 청킹 전략 설계로 검색 정확도 향상
  - 비동기 처리로 대용량 문서 업로드 성능 개선

**학습:**
독립 프로토타입으로 먼저 검증한 후 메인 프로젝트에 통합하는 접근 방식의 장점을 경험했습니다. RAG 파이프라인의 각 단계(문서 파싱, 청킹, 임베딩, 검색, 생성)를 이해하고 최적화하는 과정을 배웠습니다.

### 3. 관련 노트 추천 시스템 설계 (계획 단계)

**초기 고민:**
단순히 AI로 모든 노트를 분석해서 추천하면 응답 속도와 비용 문제가 생길 것 같았습니다. 반면 단순히 인기도나 최신순으로만 추천하면 사용자의 학습 맥락과 맞지 않을 수 있었습니다.

**설계 방향:**
1. **1차 추천: 그래프 기반**
   - PostgreSQL에 노트 간 참조 관계를 그래프 구조로 저장
   - 사용자들이 실제로 함께 본 노트를 기반으로 빠르게 추천

2. **2차 추천: AI 분석**
   - 그래프에 없는 새로운 연결을 AI가 발견
   - 비동기 처리로 비용 최적화

### 4. Electron 기반 크로스 플랫폼 데스크톱 앱 개발

**직면한 문제:**
웹 애플리케이션을 데스크톱 환경으로 확장하면서, 파일 시스템 접근과 네이티브 UI 기능이 필요했습니다. 동시에 기존에 개발한 Next.js 기반 UI를 최대한 재활용하고 싶었습니다.

**해결 과정:**
1. **프로세스 분리 전략**
   - `main` 프로세스: 파일 시스템 접근, 네이티브 기능 처리
   - `renderer` 프로세스: Next.js 기반 사용자 인터페이스

2. **안전한 IPC 통신**
   - `ipcHandlers.ts`를 통해 파일 CRUD, 프로젝트 관리 등 핵심 로직 처리
   - main/renderer 프로세스 간 데이터 전달 시 보안 고려

3. **복잡한 상태 관리**
   - 멀티 탭 및 멀티 에디터 기능 구현 (`useEditorManager` 훅)
   - 파일-탭 동기화: 파일 트리에서 파일 삭제 시 열려 있는 탭 자동 종료 (`useFileEvents`와 `useTabManager` 연동)

**학습:**
Electron의 프로세스 격리 모델과 IPC 통신 구조를 이해하게 되었습니다. 특히 파일 시스템 변경과 UI 상태를 동기화하는 이벤트 기반 아키텍처의 설계 방법을 배웠습니다.

### 5. 인프라 구축: 직접 관리하며 배우기

**직면한 선택:**
초기 배포 시 두 가지 옵션이 있었습니다:
- **Option A**: Cloud SQL (관리형 DB) - 설정 간편, 자동 백업
- **Option B**: VM에 PostgreSQL 직접 구축 - 완전한 제어권, 비용 절감

**선택 이유:**
신입 개발자로서 **"직접 부딪히며 배우는 것"** 을 우선시했습니다:
1. DB 엔진 설정부터 쿼리 최적화까지 전 과정 경험
2. 문제 발생 시 직접 로그를 분석하고 해결하는 능력 향상
3. 개인 프로젝트 예산 고려

**구현 내용:**
- **컨테이너 기반 배포**
  - Docker를 활용한 NestJS 백엔드 컨테이너화
  - 로컬 개발 환경과 운영 환경의 일관성 확보

- **데이터베이스 직접 관리**
  - GCP Compute Engine VM 내 PostgreSQL 직접 설치 및 설정
  - 스키마 모델링부터 쿼리 최적화까지 제어권 확보

- **정적 리소스 분리**
  - GCS를 활용한 이미지, 영상 등 정적 파일 저장
  - 서버 스토리지 부하 감소 및 데이터 안정성 향상

**노트 퍼블리싱 시스템:**
- 공개 노트를 정적 HTML로 변환하여 GCS에 배포
- 별도의 웹 서버 없이 효율적인 노트 공유 구현
- SEO 최적화를 위한 메타 태그 및 사이트맵 자동 생성

**학습:**
관리형 서비스의 편리함 대신 직접 구축을 선택하면서, 인프라 전반에 대한 이해도를 높일 수 있었습니다. 특히 서버 배포, 데이터베이스 관리, 클라우드 스토리지 연동 등 백엔드 개발자로서 필요한 경험을 쌓을 수 있었습니다.

## 프로젝트를 통해 배운 점

이 프로젝트를 통해 기획부터 개발, 배포, 운영까지 서비스의 전반적인 라이프사이클을 경험했습니다. 특히 크로스 플랫폼 환경에서 사용자 로그인 상태를 어떻게 관리할지 깊게 고민하는 계기가 되었습니다. 웹의 JWT 토큰 방식과 데스크톱 앱의 세션 방식을 구분하여 각 플랫폼에 최적화된 인증 전략을 구현하면서, 사용자 편의성과 보안성을 모두 고려한 시스템 설계의 중요성을 깨달았습니다.
